/**
 * File:
 *   ui.ycp
 *
 * Module:
 *   NFS server
 *
 * Summary:
 *   Network NFS server dialogs
 *
 * Authors:
 *   Jan Holesovky <kendy@suse.cz>
 *   Dan Vesely (dan@suse.cz)
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 * Network NFS server dialogs
 *
 */

{

    textdomain "nfs_server";

    import "CWMFirewallInterfaces";
    import "Label";
    import "Mode";
    import "NfsServer";
    import "Popup";
    import "Sequencer";
    import "Wizard";
    include "nfs_server/routines.ycp";

    /**
     * The kernel-based server can handle spaces in paths,
     * the user-mode server cannot.
     */
    boolean spaces_allowed = false;

    /**
     * Ask user for a directory to export. Allow browsing.
     * @param mountpoint	default value
     * @param exports		exports list to check for duplicates
     * @return			a path to export or nil if cancelled
     */
    define string GetDirectory(string mountpoint, list<map> exports) ``{
	Wizard::SetScreenShotName ("nfs-server-2a-dir");

	if (mountpoint == nil)
	    mountpoint = "";

	UI::OpenDialog(
	    `opt(`decorated),
	    `HBox(
		`HSpacing(1),
		`VBox(
		    `VSpacing(0.2),
		    `HBox (
			`TextEntry(`id(`mpent),
				   // text entry label
				   _("&Directory to Export"), mountpoint),
			`HSpacing (1),
			`VBox (
			    // button label
			    `Bottom(`PushButton (`id (`browse), `opt (`key_F6), _("&Browse...")))
			    )
			),
		    `VSpacing(0.2),
		    `ButtonBox(
			`PushButton(`id(`ok), `opt(`default, `key_F10), Label::OKButton()),
			`PushButton(`id(`cancel), `opt (`key_F9), Label::CancelButton())
			),
		    `VSpacing(0.2)),
		`HSpacing(1)
		));
	UI::SetFocus (`id (`mpent));

	any ret = nil;
	do {
	    ret = UI::UserInput();
	    mountpoint = (string) UI::QueryWidget(`id(`mpent), `Value);

	    if (ret == `ok)
	    {
		if (mountpoint == nil || mountpoint == "")
		{
		    Popup::Message(_("Enter a non-empty export path. For example, /exports."));
		    ret = nil;
		}
		else
		{
		    list allowed = FindAllowed(exports, mountpoint);
		    if (allowed != nil)
		    {
			// error popup message
			Popup::Message(_("The exports table already contains this directory."));
			ret = nil;
		    }
		    else if (!spaces_allowed && findfirstof (mountpoint, " \t") != nil)
		    {
			Popup::Message(sformat (
			// message popup; %1, %2 are package names
_("The user mode NFS server (%1) cannot export directories
with spaces in their names.
Use the kernel-based server (%2) to do that."), "nfs-server", "nfs-kernel-server"));
			ret = nil;
		    }
		    else if (SCR::Read (.target.size, mountpoint) < 0 && !Mode::config ()) {
		    // the dir does not exist
			ret = Popup::YesNo(_("The directory does not exist. Create it?")) ? `ok : nil;
		    }
		}
	    }
	    else if (ret == `browse)
	    {
		string dir = (string) UI::QueryWidget (`id (`mpent), `Value);
		if (size (dir) == 0)
		{
		    dir = "/";
		}

		// title in the file selection dialog
		dir = UI::AskForExistingDirectory(dir, _("Select the Directory to Export"));

		if (size (dir) > 0)
		{
		    integer len = size (dir);
		    // remove the trailing "/"
		    if (dir != "/" && (substring (dir,len-1,1) == "/"))
			dir = substring (dir,0,len-1);
		    UI::ChangeWidget (`id (`mpent), `Value, dir);
		}

	    }

	} while (ret != `ok && ret != `cancel);

	UI::CloseDialog();
	Wizard::RestoreScreenShotName ();

	if (ret == `ok)
	    return mountpoint;
	return nil;
    }

    /**
     * The kernel based server complains about an empty host specification
     * and wants us to use "*". But the user mode server would match it
     * only with an unqualified name. We must not use "*" there
     * to mean an anonymous client.
     */
    boolean use_star_for_anonymous = false;

    /**
     * Ask user for an entry for the allowed hosts list.
     * @param exports   the current UI version of the exports list
     * @param expath	the exported filesystem for which this is done
     * @param hosts	hosts default value
     * @param opts	options default value
     * @param allowed	current list, to check for duplicates
     * @return		[newhosts, newopts] or nil if cancelled. Options without parentheses.
     */
    define list<string> GetAllowedHosts(list<map> exports, string expath ,string hosts, string opts, 
					list<string> allowed, boolean fromedit) ``{
	Wizard::SetScreenShotName ("nfs-server-2b-hosts");
	string error = nil;
	map event = nil;
	boolean hostchanged = false;
	boolean optchanged = false;

	if (hosts == nil)   hosts = "";
	if (opts == nil)    opts = "";
	if (allowed == nil) allowed = [];
	list<string> allowed_names = maplist(string str, allowed, ``{
	    integer brpos = findfirstof(str, "(");
	    if (str != nil)
	    str = substring(str, 0, brpos);
	    return str;
	});

	UI::OpenDialog(`opt(`decorated),
		       `HBox(`HSpacing(1),
			     `VBox(`VSpacing(0.2),
				   // make at least the default options fit
				   `HSpacing (30),
				   // text entry label
				   `TextEntry(`id(`hostsent),`opt(`notify), _("&Host Wild Card"), hosts),
				   // text entry label
				   `TextEntry(`id(`optsent),`opt(`notify), _("O&ptions"),opts),
				   `VSpacing(0.2),
				   // ok pushbutton: confirm the dialog
				   `ButtonBox(`PushButton(`id(`ok), `opt(`default, `key_F10), Label::OKButton()),
					 `PushButton(`id(`cancel), `opt (`key_F9), Label::CancelButton())),
				   `VSpacing(0.2)),
			     `HSpacing(1)
			   ));

	UI::SetFocus (`id (`hostsent));
	any ret = nil;
	do {
	    event = UI::WaitForEvent();
	    ret = event["ID"]:nil;

	    if (ret == `hostsent)
	    {
		hosts = (string) UI::QueryWidget(`id(`hostsent), `Value);
		UI::ChangeWidget(`id(`hostsent), `Value, hosts);
		if (!hostchanged)
		    hostchanged = true;
		continue;
	    }

	    hosts = (string) UI::QueryWidget(`id(`hostsent), `Value);
	    if (use_star_for_anonymous && hosts == "")
	    {
		hosts = "*";
		UI::ChangeWidget (`id(`hostsent), `Value, hosts);
	    }
	    else if (!use_star_for_anonymous && hosts == "*") // #91175
	    {
		hosts = "";
		UI::ChangeWidget (`id(`hostsent), `Value, hosts);
	    }

	    if (ret == `optsent)
	    {
		// check to see if user has changed options entry in the dialogue
		// thrown due to a "Add Hosts" (as opposed to editing existing ones).
		// If yes, suggest the user with a suitable default option set.
		if (hostchanged && !fromedit)
		{
		    if (!optchanged)
		    {
			hosts = (string) UI::QueryWidget (`id(`hostsent),`Value);
			opts = GetDefaultOpts(NfsServer::enable_nfsv4, exports,hosts);
			UI::ChangeWidget (`id(`optsent),`Value,opts);
			optchanged = true;
		    }
		}
	    }

	    if (ret == `ok &&
		(!CheckNoSpaces(hosts) || !CheckExportOptions(opts)))
		ret = nil;
	    if (ret == `ok && !NfsServer::enable_nfsv4)
	    {
		if (issubstring (opts,"fsid=0")) {
		    Popup::Message(_("'fsid=0' is not a valid option unless 
NFSv4 is enabled (previous page).
"));
		    ret = nil;
		}
	    }

	    if (ret == `ok && NfsServer::enable_nfsv4)
	    {
		error = CheckUniqueRootForClient (exports,expath,hosts,opts);
		if (error != nil)
		{
		    Popup::Message(error);
		    ret = nil;
		}
	    }

	    if (ret == `ok && contains(allowed_names, hosts)) {
		// error popup message
		Popup::Message(_("Options for this wild card
are already set."));
		ret = nil;
	    }
	} while (ret != `ok && ret != `cancel);

	opts = (string) UI::QueryWidget (`id(`optsent),`Value);
	UI::CloseDialog();

	if (opts == "")
	{
	    opts = GetDefaultOpts(NfsServer::enable_nfsv4, exports,hosts);
	}

	opts = deletechars (opts, " ()");

	Wizard::RestoreScreenShotName ();

	if (ret == `ok)
	{
	    return [ hosts, opts ];
	}
	return nil;
    }


    /**
     * Opening NFS server dialog
     * @return `back, `abort, `next `or finish
     */
    define symbol BeginDialog () ``{
	Wizard::SetScreenShotName ("nfs-server-1-start");

	boolean start_nfs_server = NfsServer::start;
	string domain = (string) SCR::Read(.etc.idmapd_conf.value.General.Domain);
	if (domain == nil)
	{
		Popup::Message(_("Unable to read the /etc/idmapd.conf file. Setting the default setting for the domain to 'localdomain'."));
		domain = "localdomain";
	}

	boolean enable_nfsv4 = NfsServer::enable_nfsv4;
	boolean nfs_security = NfsServer::nfs_security;

	boolean changed = false;

	// firewall widget using CWM
	map<string, any> fw_settings = $[
	    "services": [ "service:nfs-kernel-server" ], // bnc#446163
	    "display_details": true,
	    ];
	map<string,any> fw_cwm_widget = CWMFirewallInterfaces::CreateOpenFirewallWidget (fw_settings);

	string help_text =
	// Help, part 1 of 2
_("<P>Here, choose whether to start an NFS server on your computer
and export some of your directories to others.</P>");

	help_text = help_text +
	// Help, part 2 of 2
_("<P>If you choose <B>Start NFS Server</B>, clicking <B>Next</B> opens
a configuration dialog in which to specify the directories to export.</P>");

	help_text = help_text + fw_cwm_widget["help"]:"";

	help_text = help_text +
_("<P>If the server needs to handle NFSv4 clients, check <B>Enable NFSv4</B>
and fill in the NFSv4 domain name you want the ID mapping daemon to use. Leave
it as localdomain or refer to the man page for idmapd and idmapd.conf if you are not sure.</P>
");

	help_text = help_text +
	    // FIXME: use %1 as nfs-utils.src.rpm produces nfs-kernel-server.rpm
_("<P>If the server and client must authenticate using GSS library, check the
<B>Enable GSS Security</B> box. To use GSS API, you currently need to have Kerberos and gssapi (nfs-utils > 1.0.7) on your system.</P>
");

	/* The end of the definitions */

	term nfs_contents =
		// frame label
		`Frame(_("NFS Server"),
		       `VBox(`VSpacing(0.2),
			     `RadioButtonGroup(`id(`rbgroup),
				// radio button label
					       `VBox(`Left(`RadioButton(`id(`servyes), `opt (`notify), _("&Start"), start_nfs_server)),
				//radio button label
						     `Left(`RadioButton(`id(`servno), `opt (`notify), _("Do &Not Start"), !start_nfs_server)))),
			     `VSpacing(0.2)));
	term fw_contents =
	    // frame label
	    `Frame (_("Firewall"),
		    `VBox(`VSpacing(0.2),
			  fw_cwm_widget["custom_widget"]:`Empty (),
			  `VSpacing(0.2)));

	term nfsv4_contents =
	    `Frame (_("Enable NFSv4"),
		    `VBox(
			 `VSpacing(0.2),
			 `Left(`CheckBox(`id(`enable_nfsv4),`opt(`notify),_("Enable NFS&v4"), enable_nfsv4)),
			 `VSpacing(0.2),
			  `TextEntry (`id(`domain),_("Enter NFSv4 do&main name:"), domain),
			 `VSpacing(0.2)
			)
		);


	term sec_contents =
			 `Left(`CheckBox(`id(`nfs_security),`opt(`notify),_("Enable &GSS Security"),nfs_security));


	term contents = `HVSquash (
				`VBox (
				       nfs_contents,
				       `VSpacing (1),
				        fw_contents,
				       `VSpacing (1),
					nfsv4_contents,
				       `VSpacing (1),
					sec_contents
				)
			);

	// dialog title
	Wizard::SetContents(_("NFS Server Configuration"),
			      contents, help_text, true, true);
	Wizard::DisableBackButton();
	Wizard::SetAbortButton(`abort, Label::CancelButton() );

	// initialize the widget (set the current value)
	CWMFirewallInterfaces::OpenFirewallInit (fw_cwm_widget, "");

	if (enable_nfsv4)
	{
		UI::ChangeWidget(`id(`domain),`Enabled, true);
	}
	else
	{
		UI::ChangeWidget(`id(`domain),`Enabled, false);
	}

	map event = nil;
	any ret = nil;
	do {
	    start_nfs_server = (UI::QueryWidget(`id(`rbgroup), `CurrentButton) == `servyes);
	    if (!start_nfs_server)
	    {
		Wizard::SetNextButton(`next, Label::OKButton() );
	    }
	    else
	    {
		Wizard::RestoreNextButton();
		Wizard::SetFocusToNextButton();
	    }

	    event = UI::WaitForEvent ();
	    ret = event["ID"]:nil;
	    if (ret == `enable_nfsv4)
	    {
		enable_nfsv4 = (UI::QueryWidget(`id(`enable_nfsv4),`Value)==true);
		NfsServer::enable_nfsv4 = enable_nfsv4;
		if (enable_nfsv4)
		{
			UI::ChangeWidget(`id(`domain),`Enabled, true);
		}
		else
		{
			UI::ChangeWidget(`id(`domain),`Enabled, false);
		}
	    }

	    if (ret == `nfs_security)
	    {
		nfs_security = (UI::QueryWidget(`id(`nfs_security),`Value)==true);
		NfsServer::nfs_security = nfs_security;
	    }
	    if (ret == `cancel)
	    {
		ret = `abort;
	    }

	    // handle the events, enable/disable the button, show the popup if button clicked
	    CWMFirewallInterfaces::OpenFirewallHandle (fw_cwm_widget, "", event);
	    changed =
		CWMFirewallInterfaces::OpenFirewallModified("") || // "" because method doesn't use parameter at all, nice :( 
		start_nfs_server != NfsServer::start;

	    if (ret == `abort && changed && !Popup::ReallyAbort (changed))
	    {
		ret = `again;
	    }
	} while (ret != `back && ret != `next && ret != `abort);

	if (ret == `next)
	{
	    // grab current settings, store them to SuSEFirewall::
	    CWMFirewallInterfaces::OpenFirewallStore (fw_cwm_widget, "", event);
	    NfsServer::start = start_nfs_server;
	    NfsServer::domain = (string) UI::QueryWidget(`id(`domain),`Value);
	    if (!start_nfs_server)
	    {
		return `finish;
	    }
	}

	Wizard::RestoreBackButton();
	Wizard::RestoreScreenShotName ();
	return (symbol) ret;
    }

    /**
     * Exports dialog itself
     * @return `back, `abort, `next
     */
    define symbol ExportsDialog () ``{
	Wizard::SetScreenShotName ("nfs-server-2-exports");

	// Help, part 1 of 5
	string help_text = _("<P>The upper box contains all the directories to export.
If a directory is selected, the lower box shows the hosts allowed to
mount this directory.</P>
");

	// Help, part 2 of 5
	help_text = help_text + _("<P><b>Host Wild Card</b> sets which hosts can access the selected directory.
It can be a single host, groups, wild cards, or
IP networks.</P>
");

	// #91175
	if (use_star_for_anonymous)
	{
	    // Help, part 3 of 5, variant for kernel space server
	    help_text = help_text + _("<p>Enter an asterisk (<tt>*</tt>) instead of a name to specify all hosts.</p>");
	}
	else
	{
	    // Help, part 3 of 5, variant for user space server
	    help_text = help_text + _("<p>Leave the field empty to specify all hosts.</p>");
	}

	if (NfsServer::enable_nfsv4)
	{
	    // Help, part 4 of 5, caution about fsid=0 in case NFSv4 is enabled.
	    help_text = help_text + _("<p>NFSv4 is enabled. Make sure that only one exported filesystem is marked with the fsid=0 option for a particular client.</p>");

	    // bnc#471874, NFS4 is complex and so is our UI :-/
	    // but let's fix the help at least
	    // Watch out, the space is necessary between br and slash.
	    help_text = help_text + _("<p>In case of multiple exports to a NFSv4 client,
you need to bind the exported paths with no fsid=0 to the one with fsid=0.
To export the server paths <tt>/Eve</tt> and <tt>/Adam</tt> as
<tt>/</tt> and <tt>/husband</tt>, respectively, use<br />
<pre>/Eve         10.0.0.1(fsid=0,crossmnt,ro,...)
/Eve/husband 10.0.0.1(bind=/Adam,ro,...)</pre>
</p>");
	}

	// Help, part 5 of 5
	help_text = help_text + _("<P>Refer to <tt>man exports</tt> for more information.</P>
");

	list<map<string,any> > exports = NfsServer::exports;

	term contents =  `VBox();

	contents = add (contents,`ReplacePoint(`id(`exportsrep), ExportsSelBox(exports)));

	// push button label
	contents = add (contents, `HBox(`PushButton(`id(`mpnewbut), `opt (`key_F3), _("Add &Directory")),
		      // push button label
		      `PushButton(`id(`mpeditbut), `opt (`key_F4), _("&Edit")),
		      // push button label
		      `PushButton(`id(`mpdelbut), `opt (`key_F5), _("De&lete")))
			);
		// push button label
	contents = add (contents, `VBox(`Left(`Label(`id(`allowedlab), `opt(`hstretch), "")),
		      `Table(`id(`allowedtab), `opt(`notify, `immediate),
			     // table header
			     `header(_("Host Wild Card")+"  ",
			     // table header
				     _("Options")+"  "),
			     []))
			);
		      // push button label

	contents = add (contents, `HBox(`PushButton(`id(`alwnewbut), _("Add &Host")),
		      // push button label
		      `PushButton(`id(`alweditbut), _("Ed&it")),
		      // push button label
		      `PushButton(`id(`alwdelbut), _("Dele&te")))
			);


	Wizard::SetContentsButtons (
	    // dialog title
	    _("Directories to Export"),
	    contents, help_text,
	    Label::BackButton (), Label::FinishButton());
	Wizard::SetAbortButton(`abort, Label::CancelButton() );

	map event = nil;
	any ret = nil;
	any simulated = nil; // simulated user input
	string oldmp = nil;
	// preselect an item - convenience, button enabling
	if (size (exports) > 0)
	{
	    if (NfsServer::enable_nfsv4){
		UI::ChangeWidget (`id (`exptable), `CurrentItem, exports[0,"mountpoint"]:"");
	    } else
		UI::ChangeWidget (`id (`exportsbox), `CurrentItem, exports[0,"mountpoint"]:"");
	}
	do {

	    string mountpoint = "";
	    if (NfsServer::enable_nfsv4) {
		mountpoint = (string) UI::QueryWidget (`id (`exptable), `CurrentItem);
	    }
	    else
		mountpoint = (string) UI::QueryWidget (`id (`exportsbox), `CurrentItem);

	    boolean anymp = mountpoint != nil;

	    UI::ChangeWidget (`id (`mpeditbut), `Enabled, anymp);
	    UI::ChangeWidget (`id (`mpdelbut), `Enabled, anymp);
	    UI::ChangeWidget (`id (`alwnewbut), `Enabled, anymp);
	    if (mountpoint != oldmp)
	    {
		if (mountpoint == nil)
		{
		    mountpoint = "";
		}
		UI::ChangeWidget (`id(`allowedlab), `Value, mountpoint);
		oldmp = mountpoint;
		list<string> allowed = FindAllowed (exports, mountpoint);
		UI::ChangeWidget(`id (`allowedtab), `Items,
				 AllowedTableItems (allowed != nil? allowed: []));
	    }
	    boolean anyalw = UI::QueryWidget (`id (`allowedtab), `CurrentItem) != nil;
	    UI::ChangeWidget (`id (`alweditbut), `Enabled, anyalw);
	    UI::ChangeWidget (`id (`alwdelbut), `Enabled, anyalw);

	    // Kludge, because a `Table still does not have a shortcut.
	    UI::SetFocus (`id (`allowedtab));

	    // simulated input,
	    // used for `alweditbut afted `mpnewbut
	    if (simulated == nil)
	    {
		event = UI::WaitForEvent();
		ret =  event["ID"]:nil;
		if (ret == `cancel)
		{
		    ret = `abort;
		}
	    }
	    else
	    {
		ret = simulated;
		simulated = nil;
	    }

	    if (ret == `mpnewbut)
	    {
		string mountpoint = GetDirectory(nil, exports);

		if (mountpoint != nil)
		{
		    list default_allowed = [
			sformat ("%1(%2)",
				 use_star_for_anonymous? "*":"",
				 GetDefaultOpts(NfsServer::enable_nfsv4, exports,"*")
				)
			];
		    exports = add(exports, $[ "mountpoint" : mountpoint,
					    "allowed"    : default_allowed ]);
		    UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));
		    if (NfsServer::enable_nfsv4)
			UI::ChangeWidget(`id(`exptable), `CurrentItem, mountpoint);
		    else
			UI::ChangeWidget(`id(`exportsbox), `CurrentItem, mountpoint);
		    simulated = `alweditbut;
		}
	    }
	    else if (ret == `mpeditbut)
	    {
		string mp = nil;

		if (NfsServer::enable_nfsv4)
		    mp = (string) UI::QueryWidget(`id(`exptable), `CurrentItem);
		else
		    mp = (string) UI::QueryWidget(`id(`exportsbox), `CurrentItem);

		if (mp != nil) {
		    string mountpoint = GetDirectory(mp,
						     (list<map>) filter(map ent, exports, ``{
							 return ent["mountpoint"]:"" != mp;
						     }));

		    if (mountpoint != nil) {
			exports = maplist(map<string,any> ent, exports, ``{
			    string tmp = ent["mountpoint"]:"";
			    if (tmp == mp)
			    return add(ent, "mountpoint", mountpoint);
			    return ent;
			});

			UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));

			if (NfsServer::enable_nfsv4)
			    UI::ChangeWidget(`id(`exptable), `CurrentItem, mountpoint);
			else
			    UI::ChangeWidget(`id(`exportsbox), `CurrentItem, mountpoint);
		    }
		}
	    }
	    else if (ret == `mpdelbut)
	    {
		string mountpoint = nil;

		if (NfsServer::enable_nfsv4)
		    mountpoint = (string) UI::QueryWidget(`id(`exptable), `CurrentItem);
		else
		    mountpoint = (string) UI::QueryWidget(`id(`exportsbox), `CurrentItem);

		if (mountpoint != nil) {
		    exports = filter(map<string,any> entry, exports,
				     ``(entry["mountpoint"]:"" != mountpoint));
		}

		UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));
		if (size (exports) > 0)
		{
			if (NfsServer::enable_nfsv4)
			    UI::ChangeWidget(`id(`exptable), `CurrentItem,
				      exports[0,"mountpoint"]:"");
			else
			    UI::ChangeWidget (`id (`exportsbox), `CurrentItem,
				      exports[0,"mountpoint"]:"");
		}
	    }
	    else if (ret == `alwnewbut)
	    {
		string mountpoint = nil;

		if (NfsServer::enable_nfsv4)
		    mountpoint = (string) UI::QueryWidget(`id(`exptable), `CurrentItem);
		else
		    mountpoint = (string) UI::QueryWidget(`id(`exportsbox), `CurrentItem);

		if (mountpoint != nil) {
		    list<string> allowed = FindAllowed(exports, mountpoint);

		    list<string> hostopt = GetAllowedHosts(exports, mountpoint, nil, nil, allowed, false);
		    if (hostopt != nil) {
			allowed = add(allowed, hostopt[0]:"" + "(" + hostopt[1]:"" + ")");
			exports = ReplaceInExports(exports, mountpoint, allowed);

			UI::ChangeWidget(`id(`allowedtab), `Items,
					 AllowedTableItems(allowed));
			if (NfsServer::enable_nfsv4)
			{
			    UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));
			    UI::ChangeWidget(`id(`exptable), `CurrentItem, mountpoint);
			}
		    }
		}
	    }
	    else if (ret == `alweditbut)
	    {
		string mountpoint = nil;

		if (NfsServer::enable_nfsv4)
		    mountpoint = (string) UI::QueryWidget(`id(`exptable), `CurrentItem);
		else
		    mountpoint = (string) UI::QueryWidget(`id(`exportsbox), `CurrentItem);

		if (mountpoint != nil) {
		    list<string> allowed = FindAllowed(exports, mountpoint);
		    string hosts = "";
		    string opts = "";
		    if (allowed != nil) {
			integer alw_no = (integer) UI::QueryWidget(`id(`allowedtab), `CurrentItem);
			if (alw_no != nil) {
			    list<string> ho = AllowedToHostsOpts(allowed[alw_no]:"");
			    hosts = ho[0]:"";
			    opts = ho[1]:"";
			}
			allowed = remove (allowed, alw_no);
		    }
		    list<string> hostopt = GetAllowedHosts(exports, mountpoint, hosts, opts, allowed, true);
		    if (hostopt != nil) {
			allowed = add(allowed, hostopt[0]:"" + "(" + hostopt[1]:"" + ")");
			exports = ReplaceInExports(exports, mountpoint, allowed);

			UI::ChangeWidget(`id(`allowedtab), `Items,
					 AllowedTableItems(allowed));
			if (NfsServer::enable_nfsv4)
			{
			    UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));
			    UI::ChangeWidget(`id(`exptable), `CurrentItem, mountpoint);
			}
		    }
		}
	    }
	    else if (ret == `alwdelbut)
	    {
		string mountpoint = nil;

		if (NfsServer::enable_nfsv4)
		    mountpoint = (string) UI::QueryWidget(`id(`exptable), `CurrentItem);
		else
		    mountpoint = (string) UI::QueryWidget(`id(`exportsbox), `CurrentItem);

		if (mountpoint != nil) {
		    list<string> allowed = FindAllowed(exports, mountpoint);
		    integer alwno = (integer) UI::QueryWidget(`id(`allowedtab), `CurrentItem);
		    if (allowed != nil && alwno != nil) {
			allowed = remove (allowed, alwno);
			exports = maplist(map<string,any> entry, exports, ``{
			    if (entry["mountpoint"]:"" == mountpoint)
			    entry = add(entry, "allowed", allowed);
			    return entry;
			});

			UI::ChangeWidget(`id(`allowedtab), `Items,
					 AllowedTableItems(allowed));
			if (NfsServer::enable_nfsv4)
			{
			    UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));
			    UI::ChangeWidget(`id(`exptable), `CurrentItem, mountpoint);
			}
		    }
		}
	    }
	    else if (ret == `abort && !Popup::ReallyAbort (true))
	    {
		ret = `again;
	    }
	} while (ret != `back && ret != `next && ret != `abort);

	if (ret == `next)
	{
	    NfsServer::exports = exports;
	}

	Wizard::RestoreScreenShotName ();
	return (symbol) ret;
    }


	/**
	 * Whole configuration of NfsServer but without reading and writing.
	 * For use with autoinstallation.
	 * @return sequence result
	 */
	define symbol NfsServerAutoSequence() ``{

    map Aliases = $[
    "begin"   : ``(BeginDialog ()),
    "exports"   : ``(ExportsDialog ())
    ];

    map Sequence = $[
    "ws_start"  : "begin",
    "begin"     : $[
	`next   : "exports",
	`finish : `next,
	`abort  : `abort
	],
    "exports"       : $[
	`next   : `next,
	`abort  : `abort
	]
    ];

    Wizard::CreateDialog ();
    Wizard::SetDesktopTitleAndIcon("nfs_server");

	symbol ret = Sequencer::Run(Aliases, Sequence);
	UI::CloseDialog ();
	return ret;
	}
}
