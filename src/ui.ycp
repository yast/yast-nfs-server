/**
 * File:
 *   ui.ycp
 *
 * Module:
 *   NFS server
 *
 * Summary:
 *   Network NFS server dialogs
 *
 * Authors:
 *   Jan Holesovky <kendy@suse.cz>
 *   Dan Vesely (dan@suse.cz)
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 * Network NFS server dialogs
 *
 */

{

    textdomain "nfs_server";

    import "CWMFirewallInterfaces";
    import "Label";
    import "Mode";
    import "NfsServer";
    import "Popup";
    import "Sequencer";
    import "Wizard";
    include "nfs_server/routines.ycp";

    /**
     * The kernel-based server can handle spaces in paths,
     * the user-mode server cannot.
     */
    boolean spaces_allowed = false;

    /**
     * Ask user for a directory to export. Allow browsing.
     * @param mountpoint	default value
     * @param exports		exports list to check for duplicates
     * @return			a path to export or nil if cancelled
     */
    define string GetDirectory(string mountpoint, list<map> exports) ``{
	Wizard::SetScreenShotName ("nfs-server-2a-dir");

	if (mountpoint == nil)
	    mountpoint = "";

	UI::OpenDialog(
	    `opt(`decorated),
	    `HBox(
		`HSpacing(1),
		`VBox(
		    `VSpacing(0.2),
		    `HBox (
			`TextEntry(`id(`mpent),
				   // text entry label
				   _("&Directory to Export"), mountpoint),
			`HSpacing (1),
			`VBox (
			    // button label
			    `Bottom(`PushButton (`id (`browse), `opt (`key_F6), _("&Browse...")))
			    )
			),
		    `VSpacing(0.2),
		    `HBox(
			`PushButton(`id(`ok), `opt(`default, `key_F10), Label::OKButton()),
			`PushButton(`id(`cancel), `opt (`key_F9), Label::CancelButton())
			),
		    `VSpacing(0.2)),
		`HSpacing(1)
		));
	UI::SetFocus (`id (`mpent));

	any ret = nil;
	do {
	    ret = UI::UserInput();
	    mountpoint = (string) UI::QueryWidget(`id(`mpent), `Value);

	    if (ret == `ok)
	    {
		if (mountpoint == nil || mountpoint == "")
		{
		    Popup::Message(_("Please enter a non-empty export path. Eg: /exports"));
		    ret = nil;
		}
		else
		{
		    list allowed = FindAllowed(exports, mountpoint);
		    if (allowed != nil)
		    {
			// error popup message
			Popup::Message(_("The exports table already contains this directory."));
			ret = nil;
		    }
		    else if (!spaces_allowed && findfirstof (mountpoint, " \t") != nil)
		    {
			Popup::Message(sformat (
			// message popup; %1, %2 are package names
_("The user mode NFS server (%1) cannot export directories
with spaces in their names.
Use the kernel-based server (%2) to do that."), "nfs-server", "nfs-utils"));
			ret = nil;
		    }
		    else if (SCR::Read (.target.size, mountpoint) < 0 && !Mode::config ()) {
		    // the dir does not exist
			ret = Popup::YesNo(_("The directory does not exist. Create it?")) ? `ok : nil;
		    }
		}
	    }
	    else if (ret == `browse)
	    {
		string dir = (string) UI::QueryWidget (`id (`mpent), `Value);
		if (size (dir) == 0)
		{
		    dir = "/";
		}

		// title in the file selection dialog
		dir = UI::AskForExistingDirectory(dir, _("Select the Directory to Export"));

		if (size (dir) > 0)
		{
		    integer len = size (dir);
		    // remove the trailing "/"
		    if (dir != "/" && (substring (dir,len-1,1) == "/"))
			dir = substring (dir,0,len-1);
		    UI::ChangeWidget (`id (`mpent), `Value, dir);
		}

	    }

	} while (ret != `ok && ret != `cancel);

	UI::CloseDialog();
	Wizard::RestoreScreenShotName ();

	if (ret == `ok)
	    return mountpoint;
	return nil;
    }

    /**
     * The kernel based server complains about an empty host specification
     * and wants us to use "*". But the user mode server would match it
     * only with an unqualified name. We must not use "*" there
     * to mean an anonymous client.
     */
    boolean use_star_for_anonymous = false;

    /**
     * Ask user for an entry for the allowed hosts list.
     * @param exports   the current UI version of the exports list
     * @param expath	the exported filesystem for which this is done
     * @param hosts	hosts default value
     * @param opts	options default value
     * @param allowed	current list, to check for duplicates
     * @return		[newhosts, newopts] or nil if cancelled. Options without parentheses.
     */
    define list<string> GetAllowedHosts(list<map> exports, string expath ,string hosts, string opts, 
					list<string> allowed, boolean fromedit) ``{
	Wizard::SetScreenShotName ("nfs-server-2b-hosts");
	string error = nil;
	map event = nil;
	boolean hostchanged = false;
	boolean optchanged = false;

	if (hosts == nil)   hosts = "";
	if (opts == nil)    opts = "";
	if (allowed == nil) allowed = [];
	list<string> allowed_names = maplist(string str, allowed, ``{
	    integer brpos = findfirstof(str, "(");
	    if (str != nil)
	    str = substring(str, 0, brpos);
	    return str;
	});

	UI::OpenDialog(`opt(`decorated),
		       `HBox(`HSpacing(1),
			     `VBox(`VSpacing(0.2),
				   // make at least the default options fit
				   `HSpacing (30),
				   // text entry label
				   `TextEntry(`id(`hostsent),`opt(`notify), _("&Host Wild Card"), hosts),
				   // text entry label
				   `TextEntry(`id(`optsent),`opt(`notify), _("O&ptions"),opts),
				   `VSpacing(0.2),
				   // ok pushbutton: confirm the dialog
				   `HBox(`PushButton(`id(`ok), `opt(`default, `key_F10), Label::OKButton()),
					 `PushButton(`id(`cancel), `opt (`key_F9), Label::CancelButton())),
				   `VSpacing(0.2)),
			     `HSpacing(1)
			   ));

	UI::SetFocus (`id (`hostsent));
	any ret = nil;
	do {
	    event = UI::WaitForEvent();
	    ret = event["ID"]:nil;

	    if (ret == `hostsent)
	    {
		hosts = (string) UI::QueryWidget(`id(`hostsent), `Value);
		UI::ChangeWidget(`id(`hostsent), `Value, hosts);
		if (!hostchanged)
		    hostchanged = true;
		continue;
	    }

	    hosts = (string) UI::QueryWidget(`id(`hostsent), `Value);
	    if (use_star_for_anonymous && hosts == "")
	    {
		hosts = "*";
		UI::ChangeWidget (`id(`hostsent), `Value, hosts);
	    }
	    else if (!use_star_for_anonymous && hosts == "*") // #91175
	    {
		hosts = "";
		UI::ChangeWidget (`id(`hostsent), `Value, hosts);
	    }

	    if (ret == `optsent)
	    {
		// check to see if user has changed options entry in the dialogue
		// thrown due to a "Add Hosts" (as opposed to editing existing ones).
		// If yes, suggest the user with a suitable default option set.
		if (hostchanged && !fromedit)
		{
		    if (!optchanged)
		    {
			hosts = (string) UI::QueryWidget (`id(`hostsent),`Value);
			opts = GetDefaultOpts(NfsServer::enable_nfsv4, exports,hosts);
			UI::ChangeWidget (`id(`optsent),`Value,opts);
			optchanged = true;
		    }
		}
	    }

	    if (ret == `ok &&
		(!CheckNoSpaces(hosts) || !CheckExportOptions(opts)))
		ret = nil;
	    if (ret == `ok && !NfsServer::enable_nfsv4)
	    {
		if (issubstring (opts,"fsid=0")) {
		    Popup::Message(_("'fsid=0'is not a valid option unless 
NFSv4 is enabled (previous page)"));
		    ret = nil;
		}
	    }

	    if (ret == `ok && NfsServer::enable_nfsv4)
	    {
		error = CheckUniqueRootForClient (exports,expath,hosts,opts);
		if (error != nil)
		{
		    Popup::Message(error);
		    ret = nil;
		}
	    }

	    if (ret == `ok && contains(allowed_names, hosts)) {
		// error popup message
		Popup::Message(_("Options for this wild card
are already set."));
		ret = nil;
	    }
	} while (ret != `ok && ret != `cancel);

	opts = (string) UI::QueryWidget (`id(`optsent),`Value);
	UI::CloseDialog();

	if (opts == "")
	{
	    opts = GetDefaultOpts(NfsServer::enable_nfsv4, exports,hosts);
	}

	opts = deletechars (opts, " ()");

	Wizard::RestoreScreenShotName ();

	if (ret == `ok)
	{
	    return [ hosts, opts ];
	}
	return nil;
    }


    /**
     * Opening NFS server dialog
     * @return `back, `abort, `next `or finish
     */
    define symbol BeginDialog () ``{
	Wizard::SetScreenShotName ("nfs-server-1-start");

	boolean start_nfs_server = NfsServer::start;
	string domain = (string) SCR::Read(.etc.idmapd_conf,"Domain");
	if (domain == nil)
	{
		Popup::Message(_("Unable to read /etc/idmapd.conf file. Defaulting the domain to 'localdomain'"));
		domain = "localdomain";
	}

	boolean enable_nfsv4 = NfsServer::enable_nfsv4;
	boolean nfs_security = NfsServer::nfs_security;

	boolean changed = false;

	// firewall widget using CWM
	map<string, any> fw_settings = $[
	    "services": [ "nfs-server" ],
	    "display_details": true,
	    ];
	map<string,any> fw_cwm_widget = CWMFirewallInterfaces::CreateOpenFirewallWidget (fw_settings);

	string help_text =
	// Help, part 1 of 2
_("<P>Here, choose whether to start an NFS server on your computer
and export some of your directories to others.</P>");

	help_text = help_text +
	// Help, part 2 of 2
_("<P>If you choose <B>Start NFS Server</B>, clicking <B>Next</B> opens
a configuration dialog in which to specify the directories to export.</P>");

	help_text = help_text + fw_cwm_widget["help"]:"";

	help_text = help_text +
_("<P>If the server needs to handle NFSv4 clients, enable the option <B>Enable NFSv4</B>,
and fillin the NFSv4 domain name in the text entry, for id mapping daemon to use. Please leave
it as localdomain or refer to man page for idmapd and idmapd.conf if you are not sure.</P>");

	help_text = help_text +
_("<P>If the server and client must authenticate using GSS library, please enable the <B>Enable GSS Security</B> 
checkbox. For being able to use GSS API, currently you need to have kerberos and gssapi (nfs-utils > 1.0.7) on your system</P>");

	/* The end of the definitions */

	term nfs_contents =
		// frame label
		`Frame(_("NFS Server"),
		       `VBox(`VSpacing(0.2),
			     `RadioButtonGroup(`id(`rbgroup),
				// radio button label
					       `VBox(`Left(`RadioButton(`id(`servyes), `opt (`notify), _("&Start"), start_nfs_server)),
				//radio button label
						     `Left(`RadioButton(`id(`servno), `opt (`notify), _("Do &Not Start"), !start_nfs_server)))),
			     `VSpacing(0.2)));
	term fw_contents =
	    // frame label
	    `Frame (_("Firewall"),
		    `VBox(`VSpacing(0.2),
			  fw_cwm_widget["custom_widget"]:`Empty (),
			  `VSpacing(0.2)));

	term nfsv4_contents =
	    `Frame (_("Enable NFSv4"),
		    `VBox(
			 `VSpacing(0.2),
			 `Left(`CheckBox(`id(`enable_nfsv4),`opt(`notify),_("Enable NFS&v4"), enable_nfsv4)),
			 `VSpacing(0.2),
			  `TextEntry (`id(`domain),_("Enter NFSv4 do&main name:"), domain),
			 `VSpacing(0.2)
			)
		);


	term sec_contents =
			 `Left(`CheckBox(`id(`nfs_security),`opt(`notify),_("Enable &GSS Security"),nfs_security));


	term contents = `HVSquash (
				`VBox (
				       nfs_contents,
				       `VSpacing (1),
				        fw_contents,
				       `VSpacing (1),
					nfsv4_contents,
				       `VSpacing (1),
					sec_contents
				)
			);

	// dialog title
	Wizard::SetContents(_("NFS Server Configuration"),
			      contents, help_text, true, true);

	// initialize the widget (set the current value)
	CWMFirewallInterfaces::OpenFirewallInit (fw_cwm_widget, "");

	if (enable_nfsv4)
	{
		UI::ChangeWidget(`id(`domain),`Enabled, true);
	}
	else
	{
		UI::ChangeWidget(`id(`domain),`Enabled, false);
	}

	map event = nil;
	any ret = nil;
	do {
	    start_nfs_server = (UI::QueryWidget(`id(`rbgroup), `CurrentButton) == `servyes);
	    if (!start_nfs_server)
	    {
		Wizard::SetNextButton(`next, Label::FinishButton() );

	    }
	    else
	    {
		Wizard::RestoreNextButton();
		Wizard::SetFocusToNextButton();
	    }

	    event = UI::WaitForEvent ();
	    ret = event["ID"]:nil;
	    if (ret == `enable_nfsv4)
	    {
		enable_nfsv4 = (UI::QueryWidget(`id(`enable_nfsv4),`Value)==true);
		NfsServer::enable_nfsv4 = enable_nfsv4;
		if (enable_nfsv4)
		{
			UI::ChangeWidget(`id(`domain),`Enabled, true);
		}
		else
		{
			UI::ChangeWidget(`id(`domain),`Enabled, false);
		}
	    }

	    if (ret == `nfs_security)
	    {
		nfs_security = (UI::QueryWidget(`id(`nfs_security),`Value)==true);
		NfsServer::nfs_security = nfs_security;
	    }
	    if (ret == `cancel)
	    {
		ret = `abort;
	    }

	    // handle the events, enable/disable the button, show the popup if button clicked
	    CWMFirewallInterfaces::OpenFirewallHandle (fw_cwm_widget, "", event);
	    changed =
		true ||		// TODO: fw changed, #44106
		start_nfs_server != NfsServer::start;

	    if (ret == `abort && changed && !Popup::ReallyAbort (changed))
	    {
		ret = `again;
	    }
	} while (ret != `back && ret != `next && ret != `abort);

	if (ret == `next)
	{
	    // grab current settings, store them to SuSEFirewall::
	    CWMFirewallInterfaces::OpenFirewallStore (fw_cwm_widget, "", event);
	    NfsServer::start = start_nfs_server;
	    NfsServer::domain = (string) UI::QueryWidget(`id(`domain),`Value);
	    if (!start_nfs_server)
	    {
		return `finish;
	    }
	}

	Wizard::RestoreScreenShotName ();
	return (symbol) ret;
    }

    /**
     * Exports dialog itself
     * @return `back, `abort, `next
     */
    define symbol ExportsDialog () ``{
	Wizard::SetScreenShotName ("nfs-server-2-exports");

	// Help, part 1 of 5
	string help_text = _("<P>The upper box contains all the directories to export.
If a directory is selected, the lower box shows the hosts allowed to
mount this directory.</P>
");

	// Help, part 2 of 5
	help_text = help_text + _("<P><b>Host Wild Card</b> sets which hosts can access the selected directory.
It can be a single host, groups, wild cards, or
IP networks.</P>
");

	// #91175
	if (use_star_for_anonymous)
	{
	    // Help, part 3 of 5, variant for kernel space server
	    help_text = help_text + _("<p>Enter an asterisk (<tt>*</tt>) to specify all hosts.</p>");
	}
	else
	{
	    // Help, part 3 of 5, variant for user space server
	    help_text = help_text + _("<p>Leave the field empty to specify all hosts.</p>");
	}

	if (NfsServer::enable_nfsv4)
	{
	    // Help, part 4 of 5, caution about fsid=0 in case NFSv4 is enabled.
	    help_text = help_text + _("<p>The NFSv4 option is enabled in the previous page. Make sure that only one exported filesystem is marked with fsid=0 option for a particular client.</p>");

	    help_text = help_text + _("<p>In case of multiple exports to a NFSv4 client, there is a need to bind the exported paths (not with fsid=0) to the one with fsid=0. To do this, simply add another export option, bind=/target/path where /target/path amounts to some directory existing below the fsid=0 - exported tree.</p>");
	}

	// Help, part 5 of 5
	help_text = help_text + _("<P>Refer to <tt>man exports</tt> for more information.</P>
");

	list<map<string,any> > exports = NfsServer::exports;

	term contents =  `VBox();

	contents = add (contents,`ReplacePoint(`id(`exportsrep), ExportsSelBox(exports)));

	// push button label
	contents = add (contents, `HBox(`PushButton(`id(`mpnewbut), `opt (`key_F3), _("Add &Directory")),
		      // push button label
		      `PushButton(`id(`mpeditbut), `opt (`key_F4), _("&Edit")),
		      // push button label
		      `PushButton(`id(`mpdelbut), `opt (`key_F5), _("De&lete")))
			);
		// push button label
	contents = add (contents, `VBox(`Left(`Label(`id(`allowedlab), `opt(`hstretch), "")),
		      `Table(`id(`allowedtab), `opt(`notify, `immediate),
			     // table header
			     `header(_("Host Wild Card")+"  ",
			     // table header
				     _("Options")+"  "),
			     []))
			);
		      // push button label

	contents = add (contents, `HBox(`PushButton(`id(`alwnewbut), _("Add &Host")),
		      // push button label
		      `PushButton(`id(`alweditbut), _("Ed&it")),
		      // push button label
		      `PushButton(`id(`alwdelbut), _("Dele&te")))
			);


	Wizard::SetContentsButtons (
	    // dialog title
	    _("Directories to Export"),
	    contents, help_text,
	    Label::BackButton (), Label::FinishButton());

	map event = nil;
	any ret = nil;
	any simulated = nil; // simulated user input
	string oldmp = nil;
	// preselect an item - convenience, button enabling
	if (size (exports) > 0)
	{
	    if (NfsServer::enable_nfsv4){
		UI::ChangeWidget (`id (`exptable), `CurrentItem, exports[0,"mountpoint"]:"");
	    } else
		UI::ChangeWidget (`id (`exportsbox), `CurrentItem, exports[0,"mountpoint"]:"");
	}
	do {

	    string mountpoint = "";
	    if (NfsServer::enable_nfsv4) {
		mountpoint = (string) UI::QueryWidget (`id (`exptable), `CurrentItem);
	    }
	    else
		mountpoint = (string) UI::QueryWidget (`id (`exportsbox), `CurrentItem);

	    boolean anymp = mountpoint != nil;

	    UI::ChangeWidget (`id (`mpeditbut), `Enabled, anymp);
	    UI::ChangeWidget (`id (`mpdelbut), `Enabled, anymp);
	    UI::ChangeWidget (`id (`alwnewbut), `Enabled, anymp);
	    if (mountpoint != oldmp)
	    {
		if (mountpoint == nil)
		{
		    mountpoint = "";
		}
		UI::ChangeWidget (`id(`allowedlab), `Value, mountpoint);
		oldmp = mountpoint;
		list<string> allowed = FindAllowed (exports, mountpoint);
		UI::ChangeWidget(`id (`allowedtab), `Items,
				 AllowedTableItems (allowed != nil? allowed: []));
	    }
	    boolean anyalw = UI::QueryWidget (`id (`allowedtab), `CurrentItem) != nil;
	    UI::ChangeWidget (`id (`alweditbut), `Enabled, anyalw);
	    UI::ChangeWidget (`id (`alwdelbut), `Enabled, anyalw);

	    // Kludge, because a `Table still does not have a shortcut.
	    UI::SetFocus (`id (`allowedtab));

	    // simulated input,
	    // used for `alweditbut afted `mpnewbut
	    if (simulated == nil)
	    {
		event = UI::WaitForEvent();
		ret =  event["ID"]:nil;
		if (ret == `cancel)
		{
		    ret = `abort;
		}
	    }
	    else
	    {
		ret = simulated;
		simulated = nil;
	    }

	    if (ret == `mpnewbut)
	    {
		string mountpoint = GetDirectory(nil, exports);

		if (mountpoint != nil)
		{
		    list default_allowed = [
			sformat ("%1(%2)",
				 use_star_for_anonymous? "*":"",
				 // these are the default anyway
				 // Exportfs of nfs-utils-1.0.1 gives a warning
				 // if neither of sync, async is specified.
				 GetDefaultOpts(NfsServer::enable_nfsv4, exports,"*")
				)
			];
		    exports = add(exports, $[ "mountpoint" : mountpoint,
					    "allowed"    : default_allowed ]);
		    UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));
		    if (NfsServer::enable_nfsv4)
			UI::ChangeWidget(`id(`exptable), `CurrentItem, mountpoint);
		    else
			UI::ChangeWidget(`id(`exportsbox), `CurrentItem, mountpoint);
		    simulated = `alweditbut;
		}
	    }
	    else if (ret == `mpeditbut)
	    {
		string mp = nil;

		if (NfsServer::enable_nfsv4)
		    mp = (string) UI::QueryWidget(`id(`exptable), `CurrentItem);
		else
		    mp = (string) UI::QueryWidget(`id(`exportsbox), `CurrentItem);

		if (mp != nil) {
		    string mountpoint = GetDirectory(mp,
						     (list<map>) filter(map ent, exports, ``{
							 return ent["mountpoint"]:"" != mp;
						     }));

		    if (mountpoint != nil) {
			exports = maplist(map<string,any> ent, exports, ``{
			    string tmp = ent["mountpoint"]:"";
			    if (tmp == mp)
			    return add(ent, "mountpoint", mountpoint);
			    return ent;
			});

			UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));

			if (NfsServer::enable_nfsv4)
			    UI::ChangeWidget(`id(`exptable), `CurrentItem, mountpoint);
			else
			    UI::ChangeWidget(`id(`exportsbox), `CurrentItem, mountpoint);
		    }
		}
	    }
	    else if (ret == `mpdelbut)
	    {
		string mountpoint = nil;

		if (NfsServer::enable_nfsv4)
		    mountpoint = (string) UI::QueryWidget(`id(`exptable), `CurrentItem);
		else
		    mountpoint = (string) UI::QueryWidget(`id(`exportsbox), `CurrentItem);

		if (mountpoint != nil) {
		    exports = filter(map<string,any> entry, exports,
				     ``(entry["mountpoint"]:"" != mountpoint));
		}

		UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));
		if (size (exports) > 0)
		{
			if (NfsServer::enable_nfsv4)
			    UI::ChangeWidget(`id(`exptable), `CurrentItem,
				      exports[0,"mountpoint"]:"");
			else
			    UI::ChangeWidget (`id (`exportsbox), `CurrentItem,
				      exports[0,"mountpoint"]:"");
		}
	    }
	    else if (ret == `alwnewbut)
	    {
		string mountpoint = nil;

		if (NfsServer::enable_nfsv4)
		    mountpoint = (string) UI::QueryWidget(`id(`exptable), `CurrentItem);
		else
		    mountpoint = (string) UI::QueryWidget(`id(`exportsbox), `CurrentItem);

		if (mountpoint != nil) {
		    list<string> allowed = FindAllowed(exports, mountpoint);

		    list<string> hostopt = GetAllowedHosts(exports, mountpoint, nil, nil, allowed, false);
		    if (hostopt != nil) {
			allowed = add(allowed, hostopt[0]:"" + "(" + hostopt[1]:"" + ")");
			exports = ReplaceInExports(exports, mountpoint, allowed);

			UI::ChangeWidget(`id(`allowedtab), `Items,
					 AllowedTableItems(allowed));
			if (NfsServer::enable_nfsv4)
			{
			    UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));
			    UI::ChangeWidget(`id(`exptable), `CurrentItem, mountpoint);
			}
		    }
		}
	    }
	    else if (ret == `alweditbut)
	    {
		string mountpoint = nil;

		if (NfsServer::enable_nfsv4)
		    mountpoint = (string) UI::QueryWidget(`id(`exptable), `CurrentItem);
		else
		    mountpoint = (string) UI::QueryWidget(`id(`exportsbox), `CurrentItem);

		if (mountpoint != nil) {
		    list<string> allowed = FindAllowed(exports, mountpoint);
		    string hosts = "";
		    string opts = "";
		    if (allowed != nil) {
			integer alw_no = (integer) UI::QueryWidget(`id(`allowedtab), `CurrentItem);
			if (alw_no != nil) {
			    list<string> ho = AllowedToHostsOpts(allowed[alw_no]:"");
			    hosts = ho[0]:"";
			    opts = ho[1]:"";
			}
			allowed = remove (allowed, alw_no);
		    }
		    list<string> hostopt = GetAllowedHosts(exports, mountpoint, hosts, opts, allowed, true);
		    if (hostopt != nil) {
			allowed = add(allowed, hostopt[0]:"" + "(" + hostopt[1]:"" + ")");
			exports = ReplaceInExports(exports, mountpoint, allowed);

			UI::ChangeWidget(`id(`allowedtab), `Items,
					 AllowedTableItems(allowed));
			if (NfsServer::enable_nfsv4)
			{
			    UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));
			    UI::ChangeWidget(`id(`exptable), `CurrentItem, mountpoint);
			}
		    }
		}
	    }
	    else if (ret == `alwdelbut)
	    {
		string mountpoint = nil;

		if (NfsServer::enable_nfsv4)
		    mountpoint = (string) UI::QueryWidget(`id(`exptable), `CurrentItem);
		else
		    mountpoint = (string) UI::QueryWidget(`id(`exportsbox), `CurrentItem);

		if (mountpoint != nil) {
		    list<string> allowed = FindAllowed(exports, mountpoint);
		    integer alwno = (integer) UI::QueryWidget(`id(`allowedtab), `CurrentItem);
		    if (allowed != nil && alwno != nil) {
			allowed = remove (allowed, alwno);
			exports = maplist(map<string,any> entry, exports, ``{
			    if (entry["mountpoint"]:"" == mountpoint)
			    entry = add(entry, "allowed", allowed);
			    return entry;
			});

			UI::ChangeWidget(`id(`allowedtab), `Items,
					 AllowedTableItems(allowed));
			if (NfsServer::enable_nfsv4)
			{
			    UI::ReplaceWidget(`id(`exportsrep), ExportsSelBox(exports));
			    UI::ChangeWidget(`id(`exptable), `CurrentItem, mountpoint);
			}
		    }
		}
	    }
	    else if (ret == `abort && !Popup::ReallyAbort (true))
	    {
		ret = `again;
	    }
	} while (ret != `back && ret != `next && ret != `abort);

	if (ret == `next)
	{
	    NfsServer::exports = exports;
	}

	Wizard::RestoreScreenShotName ();
	return (symbol) ret;
    }


	/**
	 * Whole configuration of NfsServer but without reading and writing.
	 * For use with autoinstallation.
	 * @return sequence result
	 */
	define symbol NfsServerAutoSequence() ``{

    map Aliases = $[
    "begin"   : ``(BeginDialog ()),
    "exports"   : ``(ExportsDialog ())
    ];

    map Sequence = $[
    "ws_start"  : "begin",
    "begin"     : $[
	`next   : "exports",
	`finish : `next,
	`abort  : `abort
	],
    "exports"       : $[
	`next   : `next,
	`abort  : `abort
	]
    ];

    Wizard::CreateDialog ();
    Wizard::SetDesktopIcon("nfs_server");

	symbol ret = Sequencer::Run(Aliases, Sequence);
	UI::CloseDialog ();
	return ret;
	}
}
