/**
 * File:
 *   modules/NfsServer.ycp
 *
 * Module:
 *   Configuration of nfs_server
 *
 * Summary:
 *   NFS server configuration data, I/O functions.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 */

{
    module "NfsServer";
    textdomain "nfs_server";

    import "Progress";
    import "Report";
    import "Service";
    import "Summary";
    import "SuSEFirewall";
    import "Wizard";


    /* default value of settings modified */
    global boolean modified = false;


    /**
     * Function sets internal variable, which indicates, that any
     * settings were modified, to "true"
     */
    global define void SetModified () {
        modified = true;
    }

    /**
     * Functions which returns if the settings were modified
     * @return boolean  settings were modified
     */
    global define boolean GetModified () {
        return modified;
    }


    global define void Set (map settings);

    /**
     * Required packages for this module to operate
     *
     */
    global list<string> required_packages = ["nfs-kernel-server"];


    /**
     * Write only, used during autoinstallation.
     * Don't run services and SuSEconfig, it's all done at one place.
     */
    global boolean write_only = false;


    /**
     * Enable nfsv4
     */
    global boolean enable_nfsv4 = true;


    /**
     * GSS Security ?
     */
    global boolean nfs_security = false;


    /**
     * Domain name to be used for nfsv4 (idmapd.conf)
     */
    global string domain = "";



    /**
     * Should the server be started?
     * New since 9.0: Exports are independent of this setting.
     */
    global boolean start = false;

    /**
     * @example
     * [
     *   $[
     *     "mountpoint": "/projects",
     *     "allowed": [ "*.local.domain(ro)", "@trusted(rw)"]
     *   ],
     *   $[ ... ],
     *   ...
     * ]
     *
     */
    global list<map<string,any> > exports = [];

    /**
     * Do we have nfslock? (nfs-utils: yes, nfs-server: no)
     * FIXME: check nfs-kernel-server
     */
    boolean have_nfslock = true;

    /**
     * Get all NFS server configuration from a map.
     * When called by nfs_server_auto (preparing autoinstallation data)
     * the map may be empty.
     * @param settings	$["start_nfsserver": "nfs_exports":]
     * @return	success
     * @see	exports
     */
    global define boolean Import (map settings) ``{
	/*
	if (size (settings) == 0)
	{
	    // Reset - just continue with Set (#24544).
	}*/

	// To avoid enabling nfslock if it does not exist during autoinstall
	have_nfslock = (boolean) SCR::Read (.init.scripts.exists, "nfslock");
	Set (settings);
	return true;
    }

    /**
     * Set the variables just as is and without complaining
     * @param  settings $[ start_nfsserver:, nfs_exports:, ]
     */
    global define void Set (map settings)
	``{
	start = settings["start_nfsserver"]:false;
	exports = settings["nfs_exports"]:[];
	// #260723, #287338: fix wrongly initialized variables
	// but do not extend the schema yet
	enable_nfsv4 = false;
	domain = "";
	nfs_security = false;
    }


    /**
     * Dump the NFS settings to a map, for autoinstallation use.
     * @return	$["start_nfsserver": "nfs_exports":]
     * @see	exports
     */
    global define map Export () ``{
	return $[
	    "start_nfsserver": start,
	    "nfs_exports": exports,
	    ];
    }

    /**
     * Reads NFS settings from the SCR (.etc.exports),
     * from SCR (.sysnconfig.nfs) and SCR (.etc.idmapd_conf),if necessary.
     * @return true on success
     */
    global define boolean Read () ``{
	start = Service::Enabled("nfsserver");
	exports = (list<map<string,any> >) SCR::Read (.etc.exports);
	have_nfslock = (boolean) SCR::Read (.init.scripts.exists, "nfslock");
	enable_nfsv4 = (SCR::Read(.sysconfig.nfs.NFS4_SUPPORT)=="yes");
	nfs_security = (SCR::Read(.sysconfig.nfs.NFS_SECURITY_GSS)=="yes");

	if (enable_nfsv4)
	{
	    domain = (string) SCR::Read(.etc.idmapd_conf.value.General.Domain);
	}

	boolean progress_orig = Progress::set (false);
	SuSEFirewall::Read ();
	Progress::set (progress_orig);

	return exports != nil;
    }


    /**
     * Saves /etc/exports and creates missing directories.
     * @return true on success
     */
    global define boolean WriteExports () ``{
	    // create missing directories.
	    foreach (map<string, any> entry, exports, ``{
		string directory = (string) (entry["mountpoint"]:nil);
		if (SCR::Read (.target.dir, directory) == nil)
		{
		    if (! (boolean) SCR::Execute (.target.mkdir, directory))
		    {
			// not fatal - write other dirs.
			Report::Warning (sformat(_("Unable to create a missing directory:\n%1"), directory));
		    }
		}
	    });

	    // (the backup is now done by the agent)
	    if (! SCR::Write(.etc.exports, exports))
	    {
		// error popup message
		Report::Error (_("Unable to write to /etc/exports.
No changes will be made to the
exported directories.\n"));
		return false;
	    }

	    return true;
    }


    string portmapper = nil;

    /**
     * Get the used port mapper: since SLE11A3 we have rpcbind
     * instead of portmap as the default (bnc#423026)
     */
    string Portmapper() {
	if (portmapper == nil) {
	    portmapper = Service::Find(["rpcbind", "portmap"]);
	    if (portmapper == "") {
		y2error("No portmapper found");
		portmapper = "rpcbind";
	    }
	}
	return portmapper;
    }

    /**
     * Saves NFS server configuration. (exports(5))
     * Creates any missing directories.
     * @return true on success
     */
    global define boolean Write () ``{
	// if there is still work to do, don't return false immediately
	// but remember the error
	boolean ok = true;

	// dialog label
	Progress::New (_("Writing NFS Server Configuration"), " ", 2, [
	    // progress stage label
	    _("Save /etc/exports"),
	    // progress stage label
	    _("Restart services"),
	   ], [
	    // progress step label
	    _("Saving /etc/exports..."),
	    // progress step label
	    _("Restarting services..."),
	    // final progress step label
	    _("Finished") ],
	    "" );

	// help text
	if (!write_only)
	{
	    // help text
	    Wizard::RestoreHelp(_("Writing NFS server settings. Please wait..."));
	}

	Progress::NextStage ();

	// Independent of @ref start because of Heartbeat (#27001).
	if (! WriteExports ())
	{
	    Progress::Finish ();
	    return false;
	}
	if(enable_nfsv4)
	{
		SCR::Write(.sysconfig.nfs.NFS4_SUPPORT,"yes");
		if (!SCR::Write(.etc.idmapd_conf.value.General.Domain, (string)domain) || !(SCR::Write(.etc.idmapd_conf, nil)))
		{
		    Report::Error(_("Unable to write to idmapd.conf."));
		}
	}
	else
	{
		SCR::Write(.sysconfig.nfs.NFS4_SUPPORT,"no");
	}

	if(nfs_security)
	{
		SCR::Write(.sysconfig.nfs.NFS_SECURITY_GSS,"yes");
	}
	else
	{
		SCR::Write(.sysconfig.nfs.NFS_SECURITY_GSS,"no");
	}
	SCR::Write(.sysconfig.nfs,nil);

	Progress::NextStage ();

	if (!start)
	{
	    if (!write_only)
		Service::Stop ("nfsserver");

	    if (! Service::Disable("nfsserver"))
	    {
		Report::Error(Service::Error());
		ok = false;
	    }
	    if (have_nfslock)
	    {
		if (!write_only)
		    Service::Stop("nfslock");
		if (! Service::Disable("nfslock"))
		{
		    Report::Error(Service::Error());
		    ok = false;
		}
	    }
	}
	else
	{
	    if (! Service::Enable(Portmapper ()))
	    {
		Report::Error (Service::Error());
		ok = false;
	    }
	    if (have_nfslock)
	    {
		if (! Service::Enable("nfslock"))
		{
		    Report::Error(Service::Error());
		    ok = false;
		}
	    }
	    if (! Service::Enable("nfsserver"))
	    {
		Report::Error(Service::Error());
		ok = false;
	    }

	    if (enable_nfsv4)
	    {
		if (Service::Status("idmapd") == 3 )
		{
			if (! Service::Start("idmapd"))
			{
				Report::Error(_("Unable to start idmapd. Check your domain setting."));
				ok = false;
			}
		}
		if (Service::Status("idmapd")== 0)
		{
			if (! Service::Restart("idmapd"))
			{
				Report::Error(_("Unable to restart idmapd."));
				ok = false;
			}
		}
	    }
	    else
	    {
		if (Service::Status("idmapd") == 3)
		{
			if(!Service::Stop("idmapd"))
			{
				Report::Error(_("Unable to stop idmapd."));
				ok = false;
			}
		}
	    }

	    if (nfs_security)
            {
		if (Service::Status("svcgssd") == 3 )
		{
			if (! Service::Start("svcgssd"))
			{
			    // FIXME svcgssd is gone! (only nfsserver is left)
				Report::Error(_("Unable to start svcgssd. Ensure your kerberos and gssapi (nfs-utils) setup is correct."));
				ok = false;
			}
		}
		if(Service::Status("svcgssd")== 0)
		{
			if (! Service::Restart("svcgssd"))
			{
				Report::Error(_("'svcgssd' is already running. Unable to restart it."));
				ok = false;
			}
		}
            }
	    else
	    {
		if (Service::Status("svcgssd") == 0)
		{
			if(!Service::Stop("svcgssd"))
			{
				Report::Error(_("'svcgssd' is running. Unable to stop it."));
				ok = false;
			}
		}

	    }

	    if (!write_only)
	    {
		if (Service::Status(Portmapper ()) != 0 )
		{
		    // portmap must not be started if it is running already (see bug # 9999)
		    Service::Start(Portmapper ());
		}

		Service::Stop("nfsserver");
		if (have_nfslock)
		{
		    Service::Restart("nfslock");
		}
		Service::Start("nfsserver");

		if (Service::Status("nfsserver") != 0)
		{
		    // error popup message
		    Report::Error (_("Unable to restart the NFS server.
Your changes will be active after reboot.
"));
		    ok = false;
		}
	    }
	}

	boolean progress_orig = Progress::set (false);
	SuSEFirewall::WriteOnly ();
	if (!write_only)
	{
	    SuSEFirewall::ActivateConfiguration ();
	}
	Progress::set (progress_orig);

	Progress::NextStage ();

	return ok;
    }

    /**
     * @return A summary for autoyast
     */
    global define string Summary() ``{
	string summary = "";
	// summary header; directories exported by NFS
	summary = Summary::AddHeader (summary, _("NFS Exports"));
	if (size (exports) > 0)
	{
	    foreach(map e, exports, ``{
		summary = Summary::OpenList (summary);
		summary = Summary::AddListItem (summary, e["mountpoint"]:"");
		summary = Summary::CloseList (summary);
	    });
	}
	else
	{
	    summary = Summary::AddLine (summary, Summary::NotConfigured ());
	}
	// add information reg NFSv4 support, domain and security
	if (enable_nfsv4) {
	    summary = Summary::AddLine (summary, "NFSv4 support is enabled.");
	    summary = Summary::AddLine (summary,
			sformat(_("The NFSv4 domain for idmapping is %1."),domain));
	}
	else
	    summary = Summary::AddLine (summary, "NFSv4 support is disabled.");

	if (nfs_security)
	    summary = Summary::AddLine (summary, "NFS Security using GSS is enabled.");
	else
	    summary = Summary::AddLine (summary, "NFS Security using GSS is disabled.");

	return summary;
    }


	/**
	* Return required packages for auto-installation
	* @return map of packages to be installed and to be removed
	*/
	global define map AutoPackages() ``{
		return ($["install": required_packages, "remove": []]);
	}



  /* The end of the definitions */

}
