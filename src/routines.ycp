/**
 * File:
 *   routines.ycp
 *
 * Module:
 *   Configuration of nfs server
 *
 * Summary:
 *   Network NFS routines
 *
 * Authors:
 *   Jan Holesovsky <kendy@suse.cz>
 *   Dan Vesely <dan@suse.cz>
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 * Network NFS routines
 *
 */

{
    textdomain "nfs_server";
    import "NfsServer";
    import "Popup";
    import "Report";

    /**
     * Split the allowed host specification
     * @param hosts	"hosts(opts)"
     * @return		["hosts", "opts"]
     */
    define list<string> AllowedToHostsOpts(string hosts) ``{
	integer  brpos = findfirstof(hosts, "(");
	string opts = "";
	if (brpos != nil) {
	    opts = substring(hosts, brpos+1);
	    hosts = substring(hosts, 0, brpos);

	    brpos = findfirstof(opts, ")");
	    if (brpos != nil)
		opts = substring(opts, 0, brpos);
	}
	return [ hosts, opts ];
    }

    /**
     * @param allowed	a list of allowed host specifications
     * @return		a ui table list of items
     * @example AllowedTableItems (["*.local.domain(ro)", "@trusted(rw)"])
     */
    define list<term> AllowedTableItems(list<string> allowed) ``{
	integer count = 0;
	return maplist(string str, allowed, ``{
	    list<string> sp = AllowedToHostsOpts(str);
	    term it = `item(`id(count), sp[0]:"" + " ", sp[1]:"" + " ");

	    count = count+1;
	    return it;
	});
    }

    /**
     * Find entry in exports according to the mountpoint
     * @param exports	list of exports
     * @param mp	mount point
     * @return		a list of allowed host specifications or nil if not found
     */
    define list<string> FindAllowed(list<map> exports, string mp) ``{
	list<map> flt = filter(map ent, exports, ``{
	    return ent["mountpoint"]:"" == mp;
	});
	if (flt == nil || size(flt) == 0)
	    return nil;

	return (list<string>) (flt[0, "allowed"]:nil);
    }


    /**
     * Find out whether client representations are related
     * @param clntexpr1	first client representation to which check is being made
     * @param clntexpr2	another client representatio against which the check is done
     * @return		1, if clntexpr1 is contained in clntexpr2 and -1, if otherway round,
     *                  and 0 if they are independent
     * @example		1.2.3.4 (is contained in) 1.*.3.4,
			*.abc.com (contains)xyz.abc.com and xyz.* and abc.com are independent
     *
     * FIXME This is not too intelligent. Ideally a while loop with matching '*' is required.
     * 1) Doesn't look default name domain.
     * 2) Doesn't know how to deal with *.abc.* ; only single '*' please :(
     */
    define integer ClientRelated (string clntexpr1, string clntexpr2) ``{

	integer pos = findfirstof (clntexpr2,"*");
	integer len = size (clntexpr2);

	clntexpr2 = tolower (clntexpr2);
	clntexpr1 = tolower (clntexpr1);

	if (pos == nil)
	{
	    pos = findfirstof (clntexpr1,"*");
	    if (pos == nil)
		return 0;	// FIXME We must continue investigating with name/ip resolution
				// Both expressions not having *, doesn't mean they are not
				// related.
	    return -1*ClientRelated (clntexpr2, clntexpr1);
	}

	if (clntexpr2 == "*")
	    return 1;
	if (clntexpr1 == clntexpr2)
	    return 1;

	if (pos == len - 1)		// expressions of type abc.xyz.*
	{
	    string check = substring (clntexpr2, 0, pos);
	    integer matchpos = findfirstof (clntexpr1, check);
	    if (matchpos == 0)
		return 1;

	} else if (pos == 0) {		// expressions of type *.abc.xyz

	    string check = substring (clntexpr2, 1);
	    integer matchpos = findfirstof (clntexpr1, check);
	    string right = substring (clntexpr1,matchpos);
	    if (check == right)
		return 1;

	} else {
					// expressions of type abc.*.xyz
	    string checkleft = substring (clntexpr2, 0, pos);
	    integer matchpos = findfirstof (clntexpr1, checkleft);
	    if (matchpos == 0)
	    {
		string checkright = substring (clntexpr2, pos+1);
		integer matchpos = findfirstof (clntexpr1, checkright);
		string right = substring (clntexpr1, matchpos);

		if (checkright == right)
		    return 1;
	    }
	}

	return 0;
    }


    /**
     * nfs-utils-1.0.1 gives a warning
     * if neither of sync, async is specified.
     *
     * no_subtree_check:
     *  http://nfs.sourceforge.net/#faq_c7
     *  nfs-utils-1.1.0, will switch the default from subtree_check
     *  to no_subtree_check (#233709)
     */
    const string default_options = "ro,root_squash,sync,no_subtree_check";

    /**
     * Give out appropriate default options
     * @param nfsv4	Is nfsv4 enabled ?
     * @param exports	list of exports
     * @param client	some string representation of the client (*, *.domain, ip address)
     * @return		a comma separated default options string, that is most appropriate
     */
    define string GetDefaultOpts (boolean nfsv4, list<map> exports, string client) ``{

	boolean withfsid = false;

	if (!nfsv4)
	    return default_options;

	foreach (map<string, any> entry, (list<map<string,any> >) exports, {
	    foreach (string hostops, entry["allowed"]:["()"], {
		integer  pos = findfirstof(hostops, "(");
		string opts = "";
		string clientexpr = "";
		if (pos != nil) {
		    opts = substring(hostops, pos+1);
		    clientexpr = substring(hostops, 0, pos);

		    pos = findfirstof(opts, ")");
		    if (pos != nil)
			opts = substring(opts, 0, pos);
		}
		if (ClientRelated (client, clientexpr)!=0)
		{
		    if (issubstring (opts, "fsid=0")) {
			withfsid = true;
			break;
		    }
		}
	    });
	    if (withfsid)
		break;
	});

	if (withfsid)
	    return default_options;
	else
	    return "fsid=0,crossmnt," + default_options; // bnc#471874 c1
    }


    /**
     * Report the first error that is encountered while checking for Unique NFSv4
     * psuedofilesystem root.
     * @param exports	list of exports
     * @param expath	the exported filesystem path
     * @param client	string representing a client (*, *.domain, ip address etc)
     * @param eopts	comma separated string of export options
     * @return		the first error encountered or nil
     */
     define string CheckUniqueRootForClient (list<map> exports, string expath,
						string client, string eopts) ``{
	string exportpath = "";
	string errorstring = nil;
	integer clientrelation = 0;

	if (!issubstring(eopts,"fsid=0"))	// Then no need to check for conflict.
	    return nil;

	foreach (map<string, any> entry, (list<map<string,any> >)exports, {
	    exportpath = entry["mountpoint"]:"";
	    foreach (string hostops, entry["allowed"]:["()"], {
		string opts = "";
		string clientexpr = "";
		integer pos = findfirstof (hostops,"(");
		if (pos != nil) {
		    opts = substring(hostops, pos+1);
		    clientexpr = substring(hostops, 0, pos);

		    pos = findfirstof(opts, ")");
		    if (pos != nil)
			opts = substring(opts, 0, pos);
		}
		clientrelation = ClientRelated (client, clientexpr);
		if (clientrelation != 0)
		{
		    if (issubstring (opts, "fsid=0")) {
			if (exportpath != expath) {		// Aww ! Two different roots
			    if (clientrelation == 1) {
				    errorstring =
					sformat(_("%3 and %4 are both exported with the option fsid=0
for the same client '%1' (contained in '%2')"), client, clientexpr, expath, exportpath);
			    } else {
				    errorstring =
					sformat(_("%3 and %4 are both exported with the option fsid=0
for the same client '%1' (contained in '%2')"), clientexpr, client, expath, exportpath);
			    }
			    break;
			}

		    }
		}
	    });
	    if (errorstring != nil)
		break;
	});

	return errorstring;

     }


    /**
     * @param exports	list of exports
     * @return		a ui table list of mountpoints, id'ed by themselves
     */
    define list<term> ExportsItems(list<map> exports) ``{
	return maplist(map entry, exports, ``{
	    string str = entry["mountpoint"]:"";
	    return `item(`id(str), str+" ");
	});
    }


    /**
     * @param clients	list of "host(opts)" strings
     * @return		a string that has comma-separated list of bind target paths.
     */
    define string getbindpaths (map entry) ``{

	string exportpath = entry["mountpoint"]:"";
	list<string> clients = entry["allowed"]:["()"];
	string bindpaths = "";
	list <string> paths = [];
	foreach (string hostopts, clients, {
	    integer pos = findfirstof(hostopts, "(");
	    string opts = substring(hostopts, pos+1);
	    string clientexpr = substring(hostopts, 0, pos);
	    string bindpath = "";

	    pos = findfirstof(opts, ")");
	    if (pos != nil)
		opts = substring(opts, 0, pos);
	    if (opts == ""){
		y2error ("Your /etc/exports file has errors. The export path %1 has no export options specified.", exportpath);
	    }
	    pos = search (opts,"bind=");
	    if (pos != nil){
		bindpath = substring (opts, pos+5);
		pos = findfirstof (bindpath, ",");
		if (pos != nil){
		    bindpath = substring (bindpath, 0, pos);
		}
	    }
	    if (bindpath != "")
		paths = prepend (paths, bindpath);
	});
	if (size(paths) != 0)
	    bindpaths = mergestring (paths, ",");


	return bindpaths;
    }


    /**
     * @param exports	list of exports
     * @return		a ui table list of mountpoints and the corresponding
     *			bindmount targets, if any.
     */
    define list<term> ExportsRows(list<map> exports) ``{
	return maplist(map entry, exports, ``{
	    string exportpath = entry["mountpoint"]:"";
	    string bindpaths =  getbindpaths (entry);
	    return `item(`id(exportpath), exportpath+" ", bindpaths);
	});
    }


    /**
     * @param exports	list of exports
     * @return		a SelectionBox for the mountpoints, `id(`exportsbox) containing
     *			list of exported directory paths.
     *			If nfsv4 is enabled return a table of 2 colums, first being the
     *			export path and the second one having bindmount targets as specified
     *			by in the export entries in /etc/exports
     */
    define term ExportsSelBox(list<map> exports) ``{
	if (NfsServer::enable_nfsv4) {
	    return `Table(`id(`exptable), `opt(`notify,`immediate),
			  `header(_("Directories"), _("Bindmount Targets")),
			  ExportsRows(exports));
	} else {
	    return `SelectionBox(`id(`exportsbox), `opt(`notify),
				// selection box label
				_("Dire&ctories"), ExportsItems(exports));
	}
    }

    /**
     * Check for the validity of client specification:
     * fewer than 70 chars, no blanks.
     * If invalid, a message is displayed.
     * @param name	options
     * @return		whether valid
     */
    define boolean CheckNoSpaces(string name) ``{
	if (size(name) < 70 &&
	    findfirstof(name, " \t") == nil)
	    return true;
	else
	    // error popup message
	    Report::Message(sformat(_("The wild card or options string is invalid.
It must be shorter than 70 characters and it
must not contain spaces.
")));
	return false;
    }


    /**
     * Check for the validity of export options:
     * [A-Za-z0-9=/.:,_-]*
     * If invalid, a message is displayed.
     * @param options	spaces and parentheses already removed
     * @return		whether valid
     */
    define boolean CheckExportOptions (string options) ``{
        // colon is allowed for sec= option, see man 5 exports
	if (regexpmatch (options, "[^A-Za-z0-9=/.:,_-]"))
	{
	    // error popup message
	    Report::Error (_("Invalid option.
Only letters, digits, and the characters =/.:,_- are allowed."));
	    return false;
	}
	return true;
    }


    /**
     * Check for the validity of export options: only those listed in
     * exports(5) are accepted.
     * Unused - to allow not only nfs-utils but also nfs-server.
     * If invalid, a message is displayed.
     * @param options	spaces and parentheses already removed
     * @return		whether valid
     */
    define boolean CheckExportOptions_strict (string options) ``{
	list<string> o1 = ["secure", "insecure", "rw", "ro", "sync", "async",
		   "no_wdelay", "wdelay", "nohide", "hide",
		   "no_subtree_check", "subtree_check",
		   "insecure_locks", "secure_locks", "no_auth_nlm", "auth_nlm",
		   "root_squash", "no_root_squash",
		   "all_squash", "no_all_squash"];
	list<string> o_value = ["anonuid", "anongid"];
	list<string> opts = splitstring (options, ",");

	boolean ret = true;
	opts = filter (string e, opts, ``(!contains (o1, e)));
	foreach (string e, opts, ``{
	    list<string> opt = splitstring (e, "=");
	    if (!contains (o_value, opt[0]:""))
	    {
		// error popup message
		Popup::Error (sformat (_("Unknown option: '%1'"), e));
		ret = false;
	    }
	    else if (size (opt) != 2 ||
		     !regexpmatch (opt[1]:"", "[0-9]+"))
	    {
		// error popup message
		Popup::Error (sformat (_("Invalid option: '%1'"), e));
		ret = false;
	    }
	});
	return ret;
    }

    /**
     * Check for suspicious allowed lists and warn the user.
     * Like "host(rw, sync)" with the space.
     */
    define void CheckSyntaxErrors (list<map<string,any> > exports) {
	map<string, boolean> bad_shares = $[];
	foreach (map<string, any> entry, exports, {
	    foreach (string client, entry["allowed"]:["()"], {
		if (search (client, "(") == nil ||
		    search (client, ")") == nil)
		{
		    bad_shares[entry["mountpoint"]:"?"] = true;
		}
	    });
	});
	list<string> bad_shares_l = maplist (string s, boolean d, bad_shares, ``(s));
	string bad_shares_s = mergestring (bad_shares_l, ", ");
	if (bad_shares_s != "")
	{
	    // %1 is a list of exported paths
	    Report::Warning (sformat (_("There are unbalanced parentheses in export options
for %1.
Likely, there is a spurious whitespace in the configuration file.
"),
				      bad_shares_s));
	}
    }

    /**
     * Replaces 'allowed' list in exports (for specified mountpoint)
     * @param exports		exports list
     * @param mountpoint	mount point
     * @param allowed		new allowed host list for that mout point
     * @return			modified exports list
     */
    define list<map<string,any> > ReplaceInExports(list<map<string,any> > exports, string mountpoint, list<string> allowed) ``{
	return maplist(map<string,any> entry, exports, ``{
	    if (entry["mountpoint"]:"" == mountpoint)
		entry = add(entry, "allowed", allowed);
	    return entry;
	});
    }

}
